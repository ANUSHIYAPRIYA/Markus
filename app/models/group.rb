require File.join(File.dirname(__FILE__),'/../../lib/repo/repository_factory')
# Maintains group information for a given user on a specific assignment
class Group < ActiveRecord::Base
  
  after_create :set_repo_name, :build_repository
  
  has_many :groupings
  has_many :submissions, :through => :groupings
  has_many :student_memberships, :through => :groupings
  has_many :ta_memberships, :class_name => "TAMembership", :through =>
  :groupings
  has_many :assignments, :through => :groupings


  validates_presence_of :group_name
  validates_uniqueness_of :group_name
  
  # prefix used for autogenerated group_names
  AUTOGENERATED_PREFIX = "group_"

  # Set repository name in database after a new group is created
  def set_repo_name
    self.repo_name = get_autogenerated_group_name
    self.save(false) # need to save!
  end

  # Returns the repository name for this group
  def repository_name
    return self.repo_name
  end
  
  # Returns an autogenerated name for the group using Group::AUTOGENERATED_PREFIX
  # This only works, after a barebone group record has been created in the database
  def get_autogenerated_group_name
    return Group::AUTOGENERATED_PREFIX + self.id.to_s.rjust(4, "0")
  end
  
  def grouping_for_assignment(aid)
    return groupings.first(:conditions => {:assignment_id => aid})
  end
  
  # Returns true, if and only if the configured repository setup
  # allows for externally accessible repositories, in which case
  # file submissions via the Web interface are not permitted. For
  # now, this works for Subversion repositories only.
  def repository_external_commits_only?
    if IS_REPOSITORY_ADMIN && REPOSITORY_EXTERNAL_SUBMITS_ONLY
      case REPOSITORY_TYPE
        when "svn"
          retval = true
        else
          retval = false
      end
    else
      retval = false
    end
    return retval
  end
  
  # Returns the URL for externally accessible repos
  def repository_external_access_url
    return REPOSITORY_EXTERNAL_BASE_URL + "/" + repository_name
  end
  
  # Returns true if we are in admin mode
  def repository_admin?
    return IS_REPOSITORY_ADMIN
  end
  
  def build_repository
    # Attempt to build the repository
    begin
      # create repositories and write permissions if and only if we are admin
      if repository_admin?
        Repository.get_class(REPOSITORY_TYPE).create(File.join(REPOSITORY_STORAGE, repository_name), true, REPOSITORY_PERMISSION_FILE)
        if repository_admin?
          # Each admin user will have read and write permissions on each repo
          user_permissions = {}
          Admin.all.each do |admin|
            user_permissions[admin.user_name] = Repository::Permission::READ_WRITE
          end
          # Each grader will have read and write permissions on each repo
          Ta.all.each do |ta|
            user_permissions[ta.user_name] = Repository::Permission::READ_WRITE
          end
          repo = Repository.get_class(REPOSITORY_TYPE)
          repo.set_bulk_permissions(self.repo_name, user_permissions)          
        end
      end
    rescue Exception => e
      raise e
    end
    return true
  end
  
  # Return a repository object, if possible
  def repo
    repo_loc = File.join(REPOSITORY_STORAGE, self.repository_name)
    if !repository_admin?
      if Repository.get_class(REPOSITORY_TYPE).repository_exists?(repo_loc)
        return Repository.get_class(REPOSITORY_TYPE).open(repo_loc, false, REPOSITORY_PERMISSION_FILE) # use false as a second parameter, since we are not repo admin
      else
        raise "Repository not found and MarkUs not in authoritative mode!" # repository not found, and we are not repo-admin
      end
    else
      return Repository.get_class(REPOSITORY_TYPE).open(repo_loc, true, REPOSITORY_PERMISSION_FILE)
    end
  end
end
